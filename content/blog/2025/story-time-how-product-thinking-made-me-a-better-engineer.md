---
slug: story-time-how-product-thinking-made-me-a-better-engineer
title: "Story time: How product thinking made me a better engineer"
date: 2025-07-23T12:22:07Z
draft: true
---

I still remember the retro from hell. We'd shipped our project management redesign on time, hit every technical milestone, and delivered exactly what the spec required. The architecture was clean, the performance metrics were solid, and we'd even managed to reduce technical debt along the way. By every engineering measure, it was a success.

Except nobody used it.

Three months later, adoption was still under 15%. Users complained that it didn't solve their real-world problems—the redesigned interface forced them to click through multiple screens for tasks they used to complete in one view. The new "streamlined" workflow broke their muscle memory and added steps to their most common actions. What we thought was an improvement felt like punishment to people trying to get work done.

We found ourselves back in planning meetings, talking about major architectural changes and feature additions that would take another six months to implement. What was supposed to be our big win had turned into an expensive lesson in building the wrong thing really well.

This wasn't an isolated incident. Over the next year, I watched the same pattern repeat. We'd cut scope to meet deadlines—dropping what seemed like "nice to have" features from an engineering perspective—only to discover those features were core to how people actually worked. Projects would ship on time but fail to meet adoption goals, leaving us to rebuild trust and rework systems that were technically sound but practically useless.

I was debugging the wrong layer of the stack.

## The pattern recognition

The problem was clear: we were optimizing for engineering metrics while ignoring user reality. Technical debt was manageable, but trust debt and product-market fit debt were expensive in ways our planning never accounted for. When users don't adopt your software, it doesn't matter how elegant your architecture is.

The scope cuts that made sense from our perspective often broke the value proposition entirely. We'd ship 80% of the functionality in 60% of the time, thinking we were being efficient. In reality, we were delivering 20% of the value and creating months of rework.

I needed to understand what we were missing. When a product management role opened up, I took it.

## Enter "story time"

The first thing I learned in product was the importance of what we called "story time"—long-form conversations about how people currently work and where they struggle. This wasn't just collecting user stories or writing acceptance criteria. It was deep, ethnographic understanding of actual workflows versus our assumptions.

In one early story time session, we discovered why our project management redesign had failed. We'd removed what we thought was a redundant status field—the information was available elsewhere in the interface. But that field was how managers scanned project status without clicking into details. We'd optimized for data normalization and broken the primary user workflow.

These sessions became our new requirements gathering. Instead of starting with what we could build, we started with understanding what people needed to accomplish.

## Learning to think in product

Product thinking forced me to redefine success. Instead of measuring whether code worked, I had to measure whether it worked for people and actually changed their behavior. User interviews, analytics, and behavior changes became my new test suite.

The human debug cycle operates differently than the code debug cycle. When code fails, you get immediate feedback—stack traces, error logs, failing tests. When users fail to adopt features, the feedback is delayed and often requires interpretation. A feature might work perfectly but still fail because it doesn't fit existing mental models.

This was frustrating at first. I missed the immediate feedback of compilation and test execution. But I learned that story time sessions could prevent the architectural mistakes that led to expensive rewrites. Understanding user workflows upfront was like doing architecture reviews—except instead of reviewing system constraints, we were reviewing human constraints.

## The agency shift

Moving from engineering to product meant shifting from direct to indirect impact. Instead of fixing problems by writing code, I had to motivate teams through influence and shared understanding. My debugging tools became OKRs, user research, and cross-functional collaboration.

The meta-engineering problem became optimizing for team understanding and alignment, not just system performance. Getting engineers, designers, and stakeholders aligned on user needs was as complex as debugging distributed systems—maybe more so, because humans are less predictable than machines.

What I missed most was the exacting nature of engineering work, where quality maps directly to measurable outcomes. In product work, you can do everything right and still fail due to factors outside your control.

## What engineering brings to product

But my engineering background gave me superpowers in product work. I could reality-check roadmaps against technical constraints. I understood how system architecture could enable or prevent product opportunities. Most importantly, I could ask "how would this actually work?" during user research, diving deeper into technical feasibility.

Systems thinking translated directly to understanding user workflows. Just as you need to understand data flow and dependencies in code architecture, you need to understand information flow and dependencies in human workflows. The debugging mindset worked just as well for user experience issues as for technical bugs.

Story time sessions became more valuable when combined with technical depth. Instead of just understanding what users wanted, I could explore what was technically possible and find creative solutions that bridged user needs with system constraints.

## The synthesis: Finding my stack

After a few years in product, I realized that product thinking isn't a replacement for engineering—it's a missing layer in the stack. Just like you can't optimize a database without understanding the queries, you can't optimize code without understanding the human workflows it enables.

I love product work and it's permanently changed how I approach problems. But I'm an engineer and designer at my core. The immediate satisfaction of building working systems, the elegance of well-architected solutions, the craft of removing technical friction—these are what energize me.

What I want now are hybrid roles where I can contribute to both product and engineering work, collaborating closely with design teams. The goal isn't just shipping code that works, but shipping complete and useful features that actually change how people work.

Story time has become as important as code review. User understanding is as critical as system understanding. Product thinking is now part of my engineering discipline.

The best features come from teams where engineering, product, and design thinking are integrated, not siloed. My experience crossing between these worlds taught me that we're all debugging the same system—we just focus on different layers.

I'm still debugging systems. I just expanded my definition of what the system includes.
