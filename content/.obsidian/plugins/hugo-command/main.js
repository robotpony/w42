/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HugoCommandPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/HugoScanner.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
var LOGO_PREFIX = "H\u2318";
function showNotice(message, timeout) {
  return new import_obsidian.Notice(`${LOGO_PREFIX} ${message}`, timeout);
}
function parseFrontmatter(content) {
  const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
  if (!match) {
    return null;
  }
  try {
    const yaml = (0, import_obsidian.parseYaml)(match[1]);
    if (typeof yaml !== "object" || yaml === null) {
      return null;
    }
    return yaml;
  } catch (e) {
    return null;
  }
}
function parseHugoDate(dateStr) {
  if (!dateStr) {
    return null;
  }
  const date = new Date(dateStr);
  if (isNaN(date.getTime())) {
    return null;
  }
  return date;
}
function formatDate(date) {
  if (!date) {
    return "";
  }
  const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const month = months[date.getMonth()];
  const day = String(date.getDate()).padStart(2, "0");
  const year = date.getFullYear();
  return `${month}-${day}-${year}`;
}
function normalizeTags(tags) {
  if (!tags) {
    return [];
  }
  if (Array.isArray(tags)) {
    return tags.filter((t) => typeof t === "string").map((t) => String(t));
  }
  if (typeof tags === "string") {
    return [tags];
  }
  return [];
}
async function openFile(app, file) {
  const leaf = app.workspace.getLeaf(false);
  await leaf.openFile(file);
}
function getFolderFromPath(filePath) {
  const lastSlash = filePath.lastIndexOf("/");
  if (lastSlash === -1) {
    return "";
  }
  return filePath.substring(0, lastSlash);
}
function getTitleFromItem(frontmatter, filePath) {
  if (frontmatter.title && typeof frontmatter.title === "string") {
    return frontmatter.title;
  }
  const lastSlash = filePath.lastIndexOf("/");
  const filename = lastSlash === -1 ? filePath : filePath.substring(lastSlash + 1);
  return filename.replace(/\.md$/, "");
}
function getRelativePath(filePath, contentPaths) {
  for (const contentPath of contentPaths) {
    const normalized = contentPath.trim().replace(/\/$/, "");
    if (normalized === "." || normalized === "/" || normalized === "") {
      return filePath;
    }
    if (filePath.startsWith(normalized + "/")) {
      return filePath.substring(normalized.length + 1);
    }
  }
  return filePath;
}
function getTopLevelFolder(filePath, contentPaths) {
  const relativePath = getRelativePath(filePath, contentPaths);
  const parts = relativePath.split("/");
  if (parts.length <= 1) {
    return "(root)";
  }
  return parts[0];
}
function getSubfolderTags(filePath, contentPaths) {
  const relativePath = getRelativePath(filePath, contentPaths);
  const parts = relativePath.split("/");
  if (parts.length <= 2) {
    return [];
  }
  return parts.slice(1, parts.length - 1);
}
function slugify(title) {
  return title.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-+|-+$/g, "");
}
function generateHugoFrontmatter(title) {
  const now = /* @__PURE__ */ new Date();
  const dateStr = now.toISOString();
  return `---
title: "${title}"
date: ${dateStr}
draft: true
tags: []
categories: []
description: ""
---

`;
}

// src/HugoScanner.ts
var HugoScanner = class extends import_obsidian2.Events {
  constructor(app, contentPaths) {
    super();
    this.contentCache = /* @__PURE__ */ new Map();
    this.folderCache = /* @__PURE__ */ new Set();
    this.app = app;
    this.contentPaths = contentPaths;
    this.debouncedScanFile = (0, import_obsidian2.debounce)(
      (file) => this.scanFile(file),
      100,
      true
    );
  }
  /**
   * Update content paths (called when settings change)
   */
  setContentPaths(paths) {
    this.contentPaths = paths;
  }
  /**
   * Check if a file path is within one of the configured content paths
   * Supports "." or "/" to mean the entire vault
   */
  isInContentPath(filePath) {
    if (this.contentPaths.length === 0) {
      return true;
    }
    return this.contentPaths.some((contentPath) => {
      const normalized = contentPath.trim().replace(/\/$/, "");
      if (normalized === "." || normalized === "/" || normalized === "") {
        return true;
      }
      return filePath.startsWith(normalized + "/") || filePath === normalized;
    });
  }
  /**
   * Scan all files in the vault that match content paths
   */
  async scanVault() {
    this.contentCache.clear();
    this.folderCache.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (this.isInContentPath(file.path)) {
        await this.scanFile(file);
      }
    }
    this.scanFolders();
    this.trigger("content-updated");
  }
  /**
   * Scan all folders in the vault that match content paths
   */
  scanFolders() {
    const folders = this.app.vault.getAllFolders();
    for (const folder of folders) {
      if (this.isInContentPath(folder.path)) {
        this.folderCache.add(folder.path);
      }
    }
  }
  /**
   * Scan a single file and update the cache
   */
  async scanFile(file) {
    if (!this.isInContentPath(file.path)) {
      this.contentCache.delete(file.path);
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatter = parseFrontmatter(content);
      if (!frontmatter) {
        this.contentCache.delete(file.path);
        return;
      }
      const item = this.createContentItem(file, frontmatter);
      this.contentCache.set(file.path, item);
    } catch (e) {
      this.contentCache.delete(file.path);
    }
  }
  /**
   * Create a HugoContentItem from a file and its frontmatter
   */
  createContentItem(file, frontmatter) {
    const tags = normalizeTags(frontmatter.tags);
    const categories = normalizeTags(frontmatter.categories);
    return {
      file,
      filePath: file.path,
      folder: getFolderFromPath(file.path),
      frontmatter,
      title: getTitleFromItem(frontmatter, file.path),
      date: parseHugoDate(frontmatter.date),
      isDraft: frontmatter.draft === true,
      tags,
      categories,
      description: typeof frontmatter.description === "string" ? frontmatter.description : "",
      topLevelFolder: getTopLevelFolder(file.path, this.contentPaths),
      folderTags: getSubfolderTags(file.path, this.contentPaths)
    };
  }
  /**
   * Watch for file changes and update cache
   */
  watchFiles() {
    this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.debouncedScanFile(file);
        this.trigger("content-updated");
      }
    });
    this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.debouncedScanFile(file);
        this.trigger("content-updated");
      } else if (file instanceof import_obsidian2.TFolder) {
        if (this.isInContentPath(file.path)) {
          this.folderCache.add(file.path);
          this.trigger("content-updated");
        }
      }
    });
    this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian2.TFile) {
        this.contentCache.delete(file.path);
        this.trigger("content-updated");
      } else if (file instanceof import_obsidian2.TFolder) {
        this.folderCache.delete(file.path);
        this.trigger("content-updated");
      }
    });
    this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.contentCache.delete(oldPath);
        this.debouncedScanFile(file);
        this.trigger("content-updated");
      } else if (file instanceof import_obsidian2.TFolder) {
        this.folderCache.delete(oldPath);
        if (this.isInContentPath(file.path)) {
          this.folderCache.add(file.path);
        }
        this.trigger("content-updated");
      }
    });
  }
  /**
   * Get all content items
   */
  getContent() {
    return Array.from(this.contentCache.values());
  }
  /**
   * Get content filtered by draft status
   */
  getContentByStatus(isDraft) {
    return this.getContent().filter((item) => item.isDraft === isDraft);
  }
  /**
   * Get content sorted by date (newest first by default)
   */
  getContentSorted(order = "date-desc") {
    const items = this.getContent();
    switch (order) {
      case "date-desc":
        return items.sort((a, b) => {
          if (!a.date && !b.date)
            return 0;
          if (!a.date)
            return 1;
          if (!b.date)
            return -1;
          return b.date.getTime() - a.date.getTime();
        });
      case "date-asc":
        return items.sort((a, b) => {
          if (!a.date && !b.date)
            return 0;
          if (!a.date)
            return 1;
          if (!b.date)
            return -1;
          return a.date.getTime() - b.date.getTime();
        });
      case "title":
        return items.sort((a, b) => a.title.localeCompare(b.title));
      default:
        return items;
    }
  }
  /**
   * Get all unique tags across all content
   */
  getAllTags() {
    const tagSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      for (const tag of item.tags) {
        tagSet.add(tag);
      }
      for (const cat of item.categories) {
        tagSet.add(cat);
      }
    }
    return Array.from(tagSet).sort((a, b) => a.localeCompare(b));
  }
  /**
   * Get all unique folder tags across all content
   */
  getAllFolderTags() {
    const tagSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      for (const tag of item.folderTags) {
        tagSet.add(tag);
      }
    }
    return Array.from(tagSet).sort((a, b) => a.localeCompare(b));
  }
  /**
   * Get all unique folders (top-level + subfolder tags) for filtering
   */
  getAllFolders() {
    const folderSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      if (item.topLevelFolder !== "(root)") {
        folderSet.add(item.topLevelFolder);
      }
      for (const tag of item.folderTags) {
        folderSet.add(tag);
      }
    }
    return Array.from(folderSet).sort((a, b) => a.localeCompare(b));
  }
  /**
   * Get folder hierarchy as a flat list with depth for display
   * Returns folders with their full path and nesting depth
   * Merges folders derived from files with actual folders from the vault
   */
  getFolderHierarchy() {
    const pathSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      if (item.topLevelFolder === "(root)")
        continue;
      let currentPath = item.topLevelFolder;
      pathSet.add(currentPath);
      for (const subFolder of item.folderTags) {
        currentPath = `${currentPath}/${subFolder}`;
        pathSet.add(currentPath);
      }
    }
    for (const folderPath of this.folderCache) {
      pathSet.add(folderPath);
      const parts = folderPath.split("/");
      let currentPath = "";
      for (const part of parts) {
        currentPath = currentPath ? `${currentPath}/${part}` : part;
        pathSet.add(currentPath);
      }
    }
    const paths = Array.from(pathSet).sort((a, b) => a.localeCompare(b));
    return paths.map((path) => {
      const parts = path.split("/");
      return {
        name: parts[parts.length - 1],
        // Just the folder name
        path,
        // Full path for filtering
        depth: parts.length - 1
        // 0 for top-level, 1 for first sublevel, etc.
      };
    });
  }
  /**
   * Get all unique top-level folders
   */
  getTopLevelFolders() {
    const folderSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      folderSet.add(item.topLevelFolder);
    }
    return Array.from(folderSet).sort((a, b) => {
      if (a === "(root)")
        return 1;
      if (b === "(root)")
        return -1;
      return a.localeCompare(b);
    });
  }
  /**
   * Get content count
   */
  getCount() {
    const items = this.getContent();
    const drafts = items.filter((item) => item.isDraft).length;
    return {
      total: items.length,
      drafts,
      published: items.length - drafts
    };
  }
};

// src/SidebarView.ts
var import_obsidian3 = require("obsidian");
var VIEW_TYPE_HUGO_SIDEBAR = "hugo-command-sidebar";
var HugoSidebarView = class extends import_obsidian3.ItemView {
  constructor(leaf, scanner, settings, onShowAbout, onOpenSettings) {
    super(leaf);
    this.updateListener = null;
    this.activeTagFilter = null;
    this.activeFolderTagFilter = null;
    this.searchQuery = "";
    this.collapsedFolders = /* @__PURE__ */ new Set();
    this.openDropdown = null;
    this.openDropdownTrigger = null;
    this.openInfoPopup = null;
    this.scanner = scanner;
    this.settings = settings;
    this.activeStatusFilter = settings.defaultStatusFilter;
    this.onShowAbout = onShowAbout;
    this.onOpenSettings = onOpenSettings;
  }
  getViewType() {
    return VIEW_TYPE_HUGO_SIDEBAR;
  }
  getDisplayText() {
    return `${LOGO_PREFIX} Hugo`;
  }
  getIcon() {
    return "file-text";
  }
  async onOpen() {
    this.updateListener = () => this.render();
    this.scanner.on("content-updated", this.updateListener);
    const hasContent = this.scanner.getContent().length > 0;
    if (!hasContent) {
      await this.scanner.scanVault();
    } else {
      this.render();
    }
  }
  async onClose() {
    if (this.updateListener) {
      this.scanner.off("content-updated", this.updateListener);
      this.updateListener = null;
    }
    this.closeDropdown();
    this.closeInfoPopup();
  }
  closeDropdown() {
    if (this.openDropdown) {
      this.openDropdown.remove();
      this.openDropdown = null;
    }
    this.openDropdownTrigger = null;
  }
  closeInfoPopup() {
    if (this.openInfoPopup) {
      this.openInfoPopup.remove();
      this.openInfoPopup = null;
    }
  }
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("hugo-command-sidebar");
    this.renderHeader(container);
    this.renderFilters(container);
    this.renderContentList(container);
  }
  renderHeader(container) {
    const header = container.createEl("div", { cls: "hugo-command-header" });
    const logo = header.createEl("span", {
      cls: "hugo-command-logo clickable-logo",
      text: LOGO_PREFIX
    });
    logo.addEventListener("click", () => {
      this.onShowAbout();
    });
    header.createEl("span", {
      cls: "hugo-command-title",
      text: "Hugo Command"
    });
    const newBtn = header.createEl("button", {
      cls: "clickable-icon hugo-command-new-btn",
      attr: { "aria-label": "New post" }
    });
    newBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>';
    newBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.showNewPostDropdown(newBtn);
    });
    const menuBtn = header.createEl("button", {
      cls: "clickable-icon hugo-command-menu-btn",
      attr: { "aria-label": "Menu" }
    });
    menuBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>';
    menuBtn.addEventListener("click", (evt) => {
      const menu = new import_obsidian3.Menu();
      menu.addItem((item) => {
        item.setTitle("Refresh").setIcon("refresh-cw").onClick(async () => {
          await this.scanner.scanVault();
        });
      });
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("About").setIcon("info").onClick(() => this.onShowAbout());
      });
      menu.addItem((item) => {
        item.setTitle("Settings").setIcon("settings").onClick(() => this.onOpenSettings());
      });
      menu.showAtMouseEvent(evt);
    });
  }
  renderFilters(container) {
    const filterBar = container.createEl("div", { cls: "hugo-command-filters" });
    filterBar.createEl("span", {
      cls: "hugo-command-filter-prefix",
      text: ""
    });
    const folderHierarchy = this.scanner.getFolderHierarchy();
    if (folderHierarchy.length > 0) {
      this.renderFolderFilterButton(filterBar, folderHierarchy);
    }
    const allTags = this.scanner.getAllTags();
    if (allTags.length > 0) {
      this.renderTagFilterButton(filterBar, allTags);
    }
    const statusSelect = filterBar.createEl("select", {
      cls: "hugo-command-status-filter"
    });
    const statusOptions = [
      { value: "all", label: "All" },
      { value: "published", label: "Published" },
      { value: "draft", label: "Drafts" }
    ];
    for (const opt of statusOptions) {
      const option = statusSelect.createEl("option", {
        text: opt.label,
        value: opt.value
      });
      if (opt.value === this.activeStatusFilter) {
        option.selected = true;
      }
    }
    statusSelect.addEventListener("change", () => {
      this.activeStatusFilter = statusSelect.value;
      this.render();
    });
    this.renderSearchField(filterBar);
    const counts = this.scanner.getCount();
    const infoIcon = filterBar.createEl("span", {
      cls: "hugo-command-info-icon",
      text: "\u24D8",
      attr: { "aria-label": "Content stats" }
    });
    infoIcon.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeInfoPopup();
      this.closeDropdown();
      const popup = document.createElement("div");
      popup.className = "hugo-command-info-popup";
      const rect = infoIcon.getBoundingClientRect();
      popup.style.position = "fixed";
      popup.style.top = `${rect.bottom + 4}px`;
      popup.style.right = `${window.innerWidth - rect.right}px`;
      popup.createEl("div", {
        cls: "hugo-command-info-row",
        text: `${counts.published} published`
      });
      popup.createEl("div", {
        cls: "hugo-command-info-row",
        text: `${counts.drafts} drafts`
      });
      popup.createEl("div", {
        cls: "hugo-command-info-row total",
        text: `${counts.total} total`
      });
      document.body.appendChild(popup);
      this.openInfoPopup = popup;
      const closeHandler = (e2) => {
        if (!popup.contains(e2.target) && e2.target !== infoIcon) {
          this.closeInfoPopup();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  renderSearchField(container) {
    const searchContainer = container.createEl("div", {
      cls: "hugo-command-search-container"
    });
    if (this.activeFolderTagFilter) {
      const chip = searchContainer.createEl("span", {
        cls: "hugo-command-search-chip folder-chip"
      });
      chip.createEl("span", { text: this.activeFolderTagFilter });
      const clearBtn = chip.createEl("span", {
        cls: "hugo-command-search-chip-clear",
        text: "\xD7"
      });
      clearBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.activeFolderTagFilter = null;
        this.render();
      });
    }
    if (this.activeTagFilter) {
      const chip = searchContainer.createEl("span", {
        cls: "hugo-command-search-chip"
      });
      chip.createEl("span", { text: this.activeTagFilter });
      const clearBtn = chip.createEl("span", {
        cls: "hugo-command-search-chip-clear",
        text: "\xD7"
      });
      clearBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.activeTagFilter = null;
        this.render();
      });
    }
    const searchInput = searchContainer.createEl("input", {
      cls: "hugo-command-search-input",
      attr: {
        type: "text",
        placeholder: "Search..."
      }
    });
    searchInput.value = this.searchQuery;
    searchInput.addEventListener("input", () => {
      this.searchQuery = searchInput.value;
      this.render();
    });
    if (this.searchQuery) {
      setTimeout(() => {
        searchInput.focus();
        searchInput.setSelectionRange(searchInput.value.length, searchInput.value.length);
      }, 0);
    }
    const hasFilters = this.activeTagFilter || this.activeFolderTagFilter || this.searchQuery;
    if (hasFilters) {
      const clearAll = searchContainer.createEl("span", {
        cls: "hugo-command-search-clear",
        text: "\xD7"
      });
      clearAll.addEventListener("click", (e) => {
        e.stopPropagation();
        this.activeTagFilter = null;
        this.activeFolderTagFilter = null;
        this.searchQuery = "";
        this.render();
      });
    }
  }
  renderTagFilterButton(container, allTags) {
    const trigger = container.createEl("span", {
      cls: "hugo-command-filter-trigger"
    });
    trigger.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg><span>Tags</span>';
    trigger.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeDropdown();
      const dropdown = document.createElement("div");
      dropdown.className = "hugo-command-tag-dropdown";
      const rect = trigger.getBoundingClientRect();
      dropdown.style.position = "fixed";
      dropdown.style.top = `${rect.bottom + 4}px`;
      dropdown.style.left = `${rect.left}px`;
      for (const tag of allTags) {
        const tagItem = dropdown.createEl("div", {
          cls: "hugo-command-tag-item",
          text: tag
        });
        if (tag === this.activeTagFilter) {
          tagItem.addClass("active");
        }
        tagItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeTagFilter = tag === this.activeTagFilter ? null : tag;
          this.closeDropdown();
          this.render();
        });
      }
      if (this.activeTagFilter) {
        dropdown.createEl("div", { cls: "hugo-command-tag-separator" });
        const clearItem = dropdown.createEl("div", {
          cls: "hugo-command-tag-item clear",
          text: "Clear filter"
        });
        clearItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeTagFilter = null;
          this.closeDropdown();
          this.render();
        });
      }
      document.body.appendChild(dropdown);
      this.openDropdown = dropdown;
      const closeHandler = (e2) => {
        if (!dropdown.contains(e2.target) && e2.target !== trigger) {
          this.closeDropdown();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  renderFolderFilterButton(container, folderHierarchy) {
    const trigger = container.createEl("span", {
      cls: "hugo-command-filter-trigger"
    });
    trigger.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg><span>Folder</span>';
    trigger.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeDropdown();
      const dropdown = document.createElement("div");
      dropdown.className = "hugo-command-tag-dropdown";
      const rect = trigger.getBoundingClientRect();
      dropdown.style.position = "fixed";
      dropdown.style.top = `${rect.bottom + 4}px`;
      dropdown.style.left = `${rect.left}px`;
      for (const folder of folderHierarchy) {
        const depthClass = `folder-depth-${Math.min(folder.depth, 4)}`;
        const folderItem = dropdown.createEl("div", {
          cls: `hugo-command-tag-item folder-tag ${depthClass}`,
          text: folder.name
        });
        if (folder.path === this.activeFolderTagFilter) {
          folderItem.addClass("active");
        }
        folderItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeFolderTagFilter = folder.path === this.activeFolderTagFilter ? null : folder.path;
          this.closeDropdown();
          this.render();
        });
      }
      if (this.activeFolderTagFilter) {
        dropdown.createEl("div", { cls: "hugo-command-tag-separator" });
        const clearItem = dropdown.createEl("div", {
          cls: "hugo-command-tag-item clear",
          text: "Clear filter"
        });
        clearItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeFolderTagFilter = null;
          this.closeDropdown();
          this.render();
        });
      }
      document.body.appendChild(dropdown);
      this.openDropdown = dropdown;
      const closeHandler = (e2) => {
        if (!dropdown.contains(e2.target) && e2.target !== trigger) {
          this.closeDropdown();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  renderContentList(container) {
    let items = this.scanner.getContentSorted(this.settings.defaultSortOrder);
    if (this.activeStatusFilter === "draft") {
      items = items.filter((item) => item.isDraft);
    } else if (this.activeStatusFilter === "published") {
      items = items.filter((item) => !item.isDraft);
    }
    if (this.activeTagFilter) {
      items = items.filter(
        (item) => item.tags.includes(this.activeTagFilter) || item.categories.includes(this.activeTagFilter)
      );
    }
    if (this.activeFolderTagFilter) {
      items = items.filter((item) => {
        const itemPath = item.topLevelFolder === "(root)" ? "" : item.folderTags.length > 0 ? `${item.topLevelFolder}/${item.folderTags.join("/")}` : item.topLevelFolder;
        return itemPath === this.activeFolderTagFilter || itemPath.startsWith(this.activeFolderTagFilter + "/");
      });
    }
    if (this.searchQuery.trim()) {
      const query = this.searchQuery.toLowerCase().trim();
      items = items.filter((item) => {
        if (item.title.toLowerCase().includes(query))
          return true;
        if (item.tags.some((tag) => tag.toLowerCase().includes(query)))
          return true;
        if (item.categories.some((cat) => cat.toLowerCase().includes(query)))
          return true;
        if (item.description && item.description.toLowerCase().includes(query))
          return true;
        return false;
      });
    }
    if (!this.settings.showDrafts && this.activeStatusFilter === "all") {
      items = items.filter((item) => !item.isDraft);
    }
    if (items.length === 0) {
      const emptyDiv = container.createEl("div", {
        cls: "hugo-command-empty",
        text: "No content found"
      });
      return;
    }
    const folders = this.scanner.getTopLevelFolders();
    const groupedItems = /* @__PURE__ */ new Map();
    for (const folder of folders) {
      groupedItems.set(folder, []);
    }
    for (const item of items) {
      const folderItems = groupedItems.get(item.topLevelFolder);
      if (folderItems) {
        folderItems.push(item);
      }
    }
    for (const folder of folders) {
      const folderItems = groupedItems.get(folder) || [];
      if (folderItems.length === 0)
        continue;
      this.renderFolderGroup(container, folder, folderItems);
    }
  }
  renderFolderGroup(container, folder, items) {
    const group = container.createEl("div", { cls: "hugo-command-folder-group" });
    const isCollapsed = this.collapsedFolders.has(folder);
    const header = group.createEl("div", {
      cls: `hugo-command-folder-header ${isCollapsed ? "collapsed" : ""}`
    });
    const chevron = header.createEl("span", {
      cls: "hugo-command-folder-chevron",
      text: isCollapsed ? "\u25B8" : "\u25BE"
    });
    header.createEl("span", {
      cls: "hugo-command-folder-name",
      text: folder
    });
    header.addEventListener("click", () => {
      if (this.collapsedFolders.has(folder)) {
        this.collapsedFolders.delete(folder);
      } else {
        this.collapsedFolders.add(folder);
      }
      this.render();
    });
    if (!isCollapsed) {
      const list = group.createEl("ul", { cls: "hugo-command-list" });
      for (const item of items) {
        this.renderContentItem(list, item);
      }
    }
  }
  renderContentItem(list, item) {
    const listItem = list.createEl("li", { cls: "hugo-command-item" });
    const badge = listItem.createEl("span", {
      cls: `hugo-command-badge ${item.isDraft ? "draft" : "published"}`,
      text: item.isDraft ? "D" : "P"
    });
    badge.setAttribute("aria-label", item.isDraft ? "Draft" : "Published");
    const title = listItem.createEl("span", {
      cls: "hugo-command-item-title",
      text: item.title
    });
    title.addEventListener("click", () => {
      openFile(this.app, item.file);
    });
    const frontmatterTags = [...item.tags, ...item.categories];
    const folderTags = item.folderTags;
    this.renderItemInfoDropdown(listItem, item.date, frontmatterTags, folderTags);
  }
  renderItemInfoDropdown(container, date, frontmatterTags, folderTags) {
    const trigger = container.createEl("span", {
      cls: "hugo-command-item-info-trigger",
      text: "\u24D8"
    });
    trigger.addEventListener("click", (e) => {
      e.stopPropagation();
      if (this.openDropdownTrigger === trigger) {
        this.closeDropdown();
        return;
      }
      this.closeDropdown();
      const dropdown = document.createElement("div");
      dropdown.className = "hugo-command-tag-dropdown";
      const rect = trigger.getBoundingClientRect();
      const sidebarRoot = this.leaf.getRoot();
      const isRightSidebar = sidebarRoot === this.app.workspace.rightSplit;
      dropdown.style.position = "fixed";
      dropdown.style.top = `${rect.bottom + 4}px`;
      if (isRightSidebar) {
        dropdown.style.right = `${window.innerWidth - rect.right}px`;
      } else {
        dropdown.style.left = `${rect.left}px`;
      }
      if (date) {
        dropdown.createEl("div", {
          cls: "hugo-command-info-date",
          text: formatDate(date)
        });
      }
      if (folderTags.length > 0) {
        if (date) {
          dropdown.createEl("div", { cls: "hugo-command-tag-separator" });
        }
        dropdown.createEl("div", {
          cls: "hugo-command-tag-section-header",
          text: "Folders"
        });
        for (const tag of folderTags) {
          const tagItem = dropdown.createEl("div", {
            cls: "hugo-command-tag-item folder-tag"
          });
          tagItem.createEl("span", {
            cls: "hugo-command-tag-label",
            text: tag
          });
          const filterBtn = tagItem.createEl("span", {
            cls: "hugo-command-tag-action",
            text: "Filter"
          });
          filterBtn.addEventListener("click", (e2) => {
            e2.stopPropagation();
            this.activeFolderTagFilter = tag;
            this.closeDropdown();
            this.render();
          });
        }
      }
      if (frontmatterTags.length > 0) {
        if (date || folderTags.length > 0) {
          dropdown.createEl("div", { cls: "hugo-command-tag-separator" });
        }
        dropdown.createEl("div", {
          cls: "hugo-command-tag-section-header",
          text: "Tags"
        });
        for (const tag of frontmatterTags) {
          const tagItem = dropdown.createEl("div", {
            cls: "hugo-command-tag-item"
          });
          tagItem.createEl("span", {
            cls: "hugo-command-tag-label",
            text: tag
          });
          const filterBtn = tagItem.createEl("span", {
            cls: "hugo-command-tag-action",
            text: "Filter"
          });
          filterBtn.addEventListener("click", (e2) => {
            e2.stopPropagation();
            this.activeTagFilter = tag;
            this.closeDropdown();
            this.render();
          });
        }
      }
      document.body.appendChild(dropdown);
      this.openDropdown = dropdown;
      this.openDropdownTrigger = trigger;
      const closeHandler = (e2) => {
        if (!dropdown.contains(e2.target) && e2.target !== trigger) {
          this.closeDropdown();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  /**
   * Update settings reference (called when settings change)
   */
  updateSettings(settings) {
    this.settings = settings;
    this.render();
  }
  /**
   * Show dropdown for selecting folder to create new post
   */
  showNewPostDropdown(trigger) {
    this.closeDropdown();
    this.closeInfoPopup();
    const dropdown = document.createElement("div");
    dropdown.className = "hugo-command-tag-dropdown";
    const rect = trigger.getBoundingClientRect();
    dropdown.style.position = "fixed";
    dropdown.style.top = `${rect.bottom + 4}px`;
    dropdown.style.right = `${window.innerWidth - rect.right}px`;
    dropdown.createEl("div", {
      cls: "hugo-command-tag-section-header",
      text: "Create in folder"
    });
    const folderHierarchy = this.scanner.getFolderHierarchy();
    const rootItem = dropdown.createEl("div", {
      cls: "hugo-command-tag-item",
      text: "(root)"
    });
    rootItem.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeDropdown();
      this.promptForNewPost("");
    });
    for (const folder of folderHierarchy) {
      const depthClass = `folder-depth-${Math.min(folder.depth, 4)}`;
      const folderItem = dropdown.createEl("div", {
        cls: `hugo-command-tag-item folder-tag ${depthClass}`,
        text: folder.name
      });
      folderItem.addEventListener("click", (e) => {
        e.stopPropagation();
        this.closeDropdown();
        this.promptForNewPost(folder.path);
      });
    }
    document.body.appendChild(dropdown);
    this.openDropdown = dropdown;
    const closeHandler = (e) => {
      if (!dropdown.contains(e.target) && e.target !== trigger) {
        this.closeDropdown();
        document.removeEventListener("click", closeHandler);
      }
    };
    setTimeout(() => document.addEventListener("click", closeHandler), 0);
  }
  /**
   * Prompt user for title and create new post
   */
  promptForNewPost(folderPath) {
    const modal = new TitlePromptModal(this.app, async (title) => {
      if (!title.trim()) {
        showNotice("Title cannot be empty");
        return;
      }
      await this.createNewPost(folderPath, title.trim());
    });
    modal.open();
  }
  /**
   * Create a new post with Hugo frontmatter
   */
  async createNewPost(folderPath, title) {
    const filename = slugify(title) || "untitled";
    const fullPath = folderPath ? `${folderPath}/${filename}.md` : `${filename}.md`;
    const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
    if (existingFile) {
      showNotice(`File already exists: ${fullPath}`);
      return;
    }
    if (folderPath) {
      const folderExists = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folderExists) {
        await this.app.vault.createFolder(folderPath);
      }
    }
    const content = generateHugoFrontmatter(title);
    const newFile = await this.app.vault.create(fullPath, content);
    showNotice(`Created: ${fullPath}`);
    await openFile(this.app, newFile);
    await this.scanner.scanVault();
  }
};
var TitlePromptModal = class extends import_obsidian3.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.inputEl = null;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("hugo-command-title-modal");
    contentEl.createEl("h3", { text: "New Post" });
    const inputContainer = contentEl.createEl("div", {
      cls: "hugo-command-title-input-container"
    });
    this.inputEl = inputContainer.createEl("input", {
      cls: "hugo-command-title-input",
      attr: {
        type: "text",
        placeholder: "Enter post title..."
      }
    });
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        this.submit();
      }
    });
    const buttonContainer = contentEl.createEl("div", {
      cls: "hugo-command-title-buttons"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
    const createBtn = buttonContainer.createEl("button", {
      cls: "mod-cta",
      text: "Create"
    });
    createBtn.addEventListener("click", () => {
      this.submit();
    });
    setTimeout(() => {
      var _a;
      return (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 10);
  }
  submit() {
    var _a;
    const title = ((_a = this.inputEl) == null ? void 0 : _a.value) || "";
    this.close();
    this.onSubmit(title);
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  contentPaths: ["."],
  showSidebarByDefault: true,
  showDrafts: true,
  defaultSortOrder: "date-desc",
  defaultStatusFilter: "draft"
};

// main.ts
var HugoCommandPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.scanner = new HugoScanner(this.app, this.settings.contentPaths);
    await this.scanner.scanVault();
    this.scanner.watchFiles();
    this.registerView(
      VIEW_TYPE_HUGO_SIDEBAR,
      (leaf) => new HugoSidebarView(
        leaf,
        this.scanner,
        this.settings,
        () => this.showAboutModal(),
        () => this.openSettings()
      )
    );
    if (this.settings.showSidebarByDefault) {
      this.app.workspace.onLayoutReady(() => {
        this.activateSidebar();
      });
    }
    this.addCommand({
      id: "toggle-hugo-sidebar",
      name: "Toggle Hugo Sidebar",
      callback: () => {
        this.toggleSidebar();
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "h"
        }
      ]
    });
    this.addCommand({
      id: "refresh-hugo-content",
      name: "Refresh Hugo Content",
      callback: async () => {
        await this.scanner.scanVault();
        this.refreshSidebar();
        showNotice("Content refreshed");
      }
    });
    this.addRibbonIcon("file-text", "Toggle Hugo Sidebar", () => {
      this.toggleSidebar();
    });
    this.addSettingTab(new HugoCommandSettingTab(this.app, this));
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.scanner.setContentPaths(this.settings.contentPaths);
    await this.scanner.scanVault();
    this.updateSidebarSettings();
  }
  async activateSidebar() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_HUGO_SIDEBAR,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async toggleSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    if (leaves.length > 0) {
      leaves.forEach((leaf) => leaf.detach());
    } else {
      await this.activateSidebar();
    }
  }
  refreshSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof HugoSidebarView) {
        view.render();
      }
    }
  }
  updateSidebarSettings() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof HugoSidebarView) {
        view.updateSettings(this.settings);
      }
    }
  }
  showAboutModal() {
    new AboutModal(this.app, this.manifest.version).open();
  }
  openSettings() {
    this.app.setting.open();
    this.app.setting.openTabById("hugo-command");
  }
};
var AboutModal = class extends import_obsidian4.Modal {
  constructor(app, version) {
    super(app);
    this.version = version;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("hugo-command-about-modal");
    const header = contentEl.createEl("div", { cls: "about-header" });
    header.createEl("span", { cls: "hugo-command-logo about-logo", text: LOGO_PREFIX });
    header.createEl("h2", { text: "Hugo Command" });
    contentEl.createEl("p", { cls: "about-version", text: `Version ${this.version}` });
    contentEl.createEl("p", {
      cls: "about-blurb",
      text: "Manage and browse your Hugo content. View posts, drafts, and filter by tags."
    });
    const details = contentEl.createEl("div", { cls: "about-details" });
    details.createEl("p", { text: "Author: Bruce Alderson" });
    const repoLink = details.createEl("p");
    repoLink.appendText("Repository: ");
    repoLink.createEl("a", {
      text: "github.com/robotpony/obsidian-plugins",
      href: "https://github.com/robotpony/obsidian-plugins"
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var HugoCommandSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: `${LOGO_PREFIX} Hugo Command Settings` });
    const aboutSection = containerEl.createEl("div", { cls: "hugo-command-about-section" });
    const aboutHeader = aboutSection.createEl("div", { cls: "about-header" });
    aboutHeader.createEl("span", { cls: "hugo-command-logo about-logo", text: LOGO_PREFIX });
    aboutHeader.createEl("span", { cls: "about-title", text: "Hugo Command" });
    aboutSection.createEl("p", {
      cls: "about-blurb",
      text: "Manage and browse your Hugo content. View posts, drafts, and filter by tags."
    });
    aboutSection.createEl("p", { cls: "about-version", text: `Version ${this.plugin.manifest.version}` });
    const aboutDetails = aboutSection.createEl("div", { cls: "about-details" });
    aboutDetails.createEl("span", { text: "By Bruce Alderson" });
    aboutDetails.appendText(" \xB7 ");
    aboutDetails.createEl("a", {
      text: "GitHub",
      href: "https://github.com/robotpony/obsidian-plugins"
    });
    new import_obsidian4.Setting(containerEl).setName("Content paths").setDesc("Folders to scan for Hugo content (one per line, e.g., content/posts)").addTextArea(
      (text) => text.setPlaceholder("content\ncontent/posts").setValue(this.plugin.settings.contentPaths.join("\n")).onChange(async (value) => {
        this.plugin.settings.contentPaths = value.split("\n").map((p) => p.trim()).filter((p) => p.length > 0);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show sidebar by default").setDesc("Show the Hugo sidebar when Obsidian starts").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showSidebarByDefault).onChange(async (value) => {
        this.plugin.settings.showSidebarByDefault = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show drafts").setDesc("Include draft posts in the content list").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showDrafts).onChange(async (value) => {
        this.plugin.settings.showDrafts = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default status filter").setDesc("Which posts to show by default when opening the sidebar").addDropdown(
      (dropdown) => dropdown.addOption("all", "All").addOption("published", "Published").addOption("draft", "Drafts").setValue(this.plugin.settings.defaultStatusFilter).onChange(async (value) => {
        this.plugin.settings.defaultStatusFilter = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default sort order").setDesc("How to sort content in the sidebar").addDropdown(
      (dropdown) => dropdown.addOption("date-desc", "Date (newest first)").addOption("date-asc", "Date (oldest first)").addOption("title", "Title (A-Z)").setValue(this.plugin.settings.defaultSortOrder).onChange(async (value) => {
        this.plugin.settings.defaultSortOrder = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
